Hello again reader. Over the years the exploitation process has obviously
shifted in complexity. What once began with the straight forward case of 
turning a single bug into a reliable exploit has now evolved more towards
combining vulnerability primitives together in an attempt to bypass each 
of the memory protection hurdles present on a modern day operating system.
With this in mind, let's jump once again into the exploitation of
Objective-C based memory corruption vulnerabilities in a modern time. 
Back in Phrack 0x42 (Phile #0x04) I wrote a paper documenting a way to turn
the most common Objective-C memory corruption primitive (an attacker
controlled Objective-C method call) into control of EIP. If you have not 
read this paper, or if it's been a while and you need to refresh, it's
probably wise to do so now, as the first half of this paper will only build
on the techniques covered in the original [1]. Contrary to the beliefs of 
Ian Beer, the techniques in the original paper are still alive and kicking 
in modern times however some adjustment is needed depending on the context 
of the vulnerability. 
--[ Dangling Objective-C Method Calls
As you're aware since you read my paper in [1], Objective-C method calls 
are implemented by passing "messages" to the receiver (object) via the
objc_msgSend() API call. 
When Objective-C objects are allocated, storage for their instance variables 
is allocated on the native heap with malloc(). The first element in this
space is a pointer to the class definition in the binary. This is typically 
referred to as the "ISA" pointer. As in: "an NSString 'IS-A' NSObject".
When dealing with bugs in Objective-C applications it is extremely common
for this ISA pointer to be attacker controlled, resulting in an Objective-C 
method call to be performed on an attacker controlled memory location.
This can occur when dealing with Use-After-Free conditions, heap overflows 
into objective-c objects, and even format bugs using the %@ format string
character. 
In my original paper [1] I wrote about how to utilize this construct to 
perform a successful cache lookup for the selector value, resulting in 
control of EIP. An alternative route to gain EIP control is to make the
Objective-C runtime think that it's finished looking through the entire 
cache and found no match for the SEL value passed in. In which case the
runtime will attempt to resolve the method's address via the class
definition (through the controlled ISA pointer) and once again use an EIP
value from memory controlled by us. This method is longer however, and adds
little benefit. But i digress, both of these methods are still completely
valid in the most current version of Mac OS X at this time Mavericks, 
(10.10).
While, at the time of the Phrack 0x42 release, this technique was fairly 
useful by itself, in modern times EIP/RIP control is only a small victory
and in no way wins the battle of process control. This is due to the fact
that even with direct control of EIP modern NX and ASLR makes it difficult 
to know a reliable absolute location in which we can store a payload and 
return to execute it.
From what i've seen, the most commonly used technique to bypass this
currently is to combine an EIP control primitive with an information leak
of a .text address in order to construct a ROP chain (returning repeatedly 
into the text segment) which either executes the needed functionality,
mprotect()'s some shellcode before executing it, or loads an existing 
executable or shared library. 
Under the right conditions, it is possible to skip some of these steps 
and turn a dangling Objective-C method call into both an information leak 
and execution control. 
In order to use this technique, we must first know the exact binary version
in use on the target. Thankfully on Mac OS X this is usually pretty easy as 
automatic updates mean that most people are running the same binary 
version. 
The specifics of the technique differ depending on the architecture of the 
target system, as well as the location of the particular SEL string which
is used in the dangling method call construct. 
Since we are already familiar with 32-bit internals, we will begin our 
investigation of dangling objc_msgSend() exploitation with the 32-bit
runtime, before moving on to look at the changes in the new run-time on 
64-bit.
--[ 32-bit dangling objc_msgSend() 
Firstly, 32-bit processes utilize the old Objective-C runtime, so the
specifics of the internals are identical to what is documented in my
original paper. However, depending on the location of the module
containing the selector string, the technique varies slightly.
----[ 32-bit Shared Region
The shared-region is a mapping which is common to all processes on the
system. The file '/var/db/dyld/dyld_shared_cache_i386' is mapped into this 
space. This file is generated by the "update_dyld_shared_cache" utility 
during system update, and contains a large selection of libraries which are
commonly used on the system. The .paths files in
"/var/db/dyld/shared_region_roots" dictate which files are contained
within. The order in which each library is added to this file is
randomized, therefore the offset into the file for a particular library
cannot be relied on. Reading the file 
'/var/db/dyld/dyld_shared_cache_i386.map' shows the order of these files.
For 32-bit processes, this file is mapped at the fixed address 0x90000000.
At this location there is a structure which described the contents of the 
shared region. 
This technique, once again, revolves around the ability to control the ISA
pointer, and to point it at a fake class struct in memory. In order to
demonstrate how this works, a small sample Objective-C class was created
(shown below). The complete example of this technique is included at the
end of this paper in the uuencoded files blob. 
        [leakme.m] 
        #import "leakme.h"
        @implementation leakme 
        -(void) log
        {
            printf("lol\n");
        } 
        @end 
In main.m, we create an instance of this object, and then use sprintf() to 
write out a string representation of the objects address, before converting
it back with atol(). This is pretty confusing, but it's basically an easy
way to trick the compiler into giving us a void pointer to the object. Type 
casting the object pointer directly will not compile with gcc.
        printf("[+] Class @ 0x%lx\n",l);
        sprintf(num,"%li",l); 
        long *ptr = atol(num); 
        ... 
        printf("[+] Overwriting object\n"); 
        *ptr = &fc; // isa ptr 
By overwriting the ISA pointer with the address of an allocation we
control, we can easily simulate a vulnerable scenario. 
